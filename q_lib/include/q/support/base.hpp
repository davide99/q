/*=============================================================================
   Copyright (c) 2014-2023 Joel de Guzman. All rights reserved.

   Distributed under the MIT License [ https://opensource.org/licenses/MIT ]
=============================================================================*/
#if !defined(CYCFI_Q_SUPPORT_BASE_HPP_DECEMBER_20_2015)
#define CYCFI_Q_SUPPORT_BASE_HPP_DECEMBER_20_2015

#include <type_traits>
#include <cstdint>
#include <cstring>
#include <algorithm>
#include "q/infra/support.hpp"
#include <q/detail/fast_math.hpp>

namespace cycfi::q {
    ////////////////////////////////////////////////////////////////////////////
    // Some macros
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // pi
    ////////////////////////////////////////////////////////////////////////////
    constexpr double pi = 3.1415926535897932384626433832795;

    ////////////////////////////////////////////////////////////////////////////
    // abs (we need ot here because std::abs may not be constexpr)
    ////////////////////////////////////////////////////////////////////////////
    template<typename T>
    constexpr T abs(T x) {
        return (x < T(0)) ? -x : x;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fast exp Taylor series approximations (from http://www.musicdsp.org/)
    ////////////////////////////////////////////////////////////////////////////
    constexpr float fast_exp3(float x) {
        return (6 + x * (6 + x * (3 + x))) * 0.16666666f;
    }

    ////////////////////////////////////////////////////////////////////////////
    // linear interpolation: Interpolates a value linearly between y1 and y2
    // given mu. If mu is 0, the result is y1. If mu is 1, then the result is
    // y2.
    ////////////////////////////////////////////////////////////////////////////
    constexpr float linear_interpolate(float y1, float y2, float mu) {
        return y1 + mu * (y2 - y1);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fast reciprocal. See http://tinyurl.com/lgmnsyg. We want to avoid
    // multiplication. So instead of 1.0f/val, we use this function which
    // is inaccurate, but fast substitute. It works by negating the exponent
    // which is assumed to be IEEE754.
    ////////////////////////////////////////////////////////////////////////////
    inline float fast_inverse(float val) {
        auto x = reinterpret_cast<std::int32_t &>(val);
        x = 0x7EF311C2 - x;
        return reinterpret_cast<float &>(x);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fast log2
    ////////////////////////////////////////////////////////////////////////////
    inline float fast_log2(float x) {
        return fastlog2(x);
    }

    inline float faster_log2(float x) {
        return fasterlog2(x);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fast pow2
    ////////////////////////////////////////////////////////////////////////////
    inline float fast_pow2(float x) {
        return fastpow2(x);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fast sqrt
    ////////////////////////////////////////////////////////////////////////////
    inline float fast_sqrt(float x) {
        return fast_pow2(fast_log2(x) / 2);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fast log10
    ////////////////////////////////////////////////////////////////////////////
    inline float fast_log10(float x) {
        return 0.301029995663981f * fast_log2(x);
    }

    inline float faster_log10(float x) {
        return 0.301029995663981f * faster_log2(x);
    }

    ////////////////////////////////////////////////////////////////////////////
    // rel_within
    ////////////////////////////////////////////////////////////////////////////
    inline bool rel_within(float a, float b, float eps) {
        return abs(a - b) <= eps * std::max(abs(a), abs(b));
    }
}

#endif
